<!DOCTYPE html>
<html>
<head>
<title>Mosby MVP使用文档</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Mosby MVP使用文档</h1>

<blockquote>
  <p>索引</p>
  
  <ul>
  <li><a href="#1">入门</a>
  <ul>
  <li><a href="#1.1">MVP简介</a></li>
  <li><a href="#1.2">Mosby简介</a></li>
  <li><a href="#1.3">Hello MVP World</a></li>
  <li><a href="#1.4">MvpPresenter的基类</a></li>
  </ul></li>
  <li><a href="#2">基础</a>
  <ul>
  <li><a href="#2.1">LCE视图</a></li>
  <li><a href="#2.2">MvpLceActivity和MvpLceFragment</a></li>
  <li><a href="#2.3">ViewState简介</a></li>
  </ul></li>
  <li><a href="#3">拓展</a>
  <ul>
  <li><a href="#3.1">思考</a></li>
  </ul></li>
  </ul>
</blockquote>

<h2 id="1">入门</h2>

<h3 id="1.1">MVP简介</h3>

<p>MVP的出发点是关注点分离，将视图和业务逻辑解耦。Model-View-Presenter三个部分可以简单理解为：</p>

<ul>
<li><strong>Model</strong>是将在视图中显示的数据。</li>
<li><strong>View</strong>是显示数据(model)的界面，同时将用户指令(事件)发送给Presenter来处理。View通常含有Presenter的引用。在Android中Activity，Fragment和ViewGroup都扮演视图的角色。</li>
<li><strong>Presenter</strong>是中间人，同时有两者的引用。<strong>请注意单词model非常有误导性</strong>。它应该是<strong>获取或处理model的业务逻辑</strong>。例如：如果你的数据库表中存储着User，而你的视图想显示用户列表，那么Presenter将有一个数据库业务逻辑(例如DAO)类的引用，Presenter通过它来查询用户列表。</li>
</ul>

<blockquote>
  <p><strong>思考</strong>：MVC，MVP和MVVM之间有什么区别和联系？</p>
</blockquote>

<p><strong>消极视图</strong>：在MVP中，View是<strong>消极视图(Passive View)</strong>，也就是说它尽量不去主动做事，而是让Presenter通过抽象方式控制View，例如Presenter调用<code>view.showLoading()</code>方法来显示加载效果，但Presenter不应该控制View的具体实现，例如动画，所以Presenter不应该调用<code>view.startAnimation()</code>这样的方法。</p>

<p><img src="http://7xsct4.com1.z0.glb.clouddn.com/16-5-4/67007311.jpg" alt="" /></p>

<h3 id="1.2">Mosby简介</h3>

<p><strong>设计目标</strong>：让你能用清晰的Model-View-Presenter架构来构建Android app。</p>

<p><strong>注意</strong>：Mosby是一个库(library)，不是一个框架(framework)。</p>

<blockquote>
  <p><strong>思考</strong>：什么是library？什么是framework？它们的区别是什么？</p>
</blockquote>

<p>Mosby的内核是一个基于委托模式(delegation)的很精简的库。你可以使用委托(delegation)和组合(composition)将Mosby集成到你的开发技术栈中。这样你就能避免框架(framework)带来的限制和约束。</p>

<blockquote>
  <p><strong>思考</strong>：什么是委托模式？委托和继承的区别是什么？使用委托有什么好处？</p>
</blockquote>

<p><strong>依赖</strong>：</p>

<p>Mosby被分成模块，你可以选择你需要的功能：</p>

<pre><code>dependencies {
    compile 'com.hannesdorfmann.mosby:mvp:2.0.1'
    compile 'com.hannesdorfmann.mosby:viewstate:2.0.1'
}
</code></pre>

<h3 id="1.3">Hello MVP World</h3>

<p>先来用Mosby MVP库来实现一个最简单的功能，页面有两个Button和一个TextView，需求如下：</p>

<ul>
<li>点击Hello按钮，显示红色文本 "Hello" + 随机数；</li>
<li>点击Goodbye按钮，显示蓝色文本 "Goodbye" + 随机数；</li>
</ul>

<p>这里假设随机数的生成过程涉及到复杂的业务逻辑计算，是一个耗时操作，需要2s时间。</p>

<p><strong>第一步</strong>我们用一个<code>AsyncTask</code>来实现这个模拟的业务逻辑，在自定义的<code>AsyncTask</code>中，要定义一个监听器，用来传递业务逻辑执行结果：</p>

<pre><code>public class GreetingGeneratorTask extends AsyncTask&lt;Void, Void, Integer&gt;{

    // Callback - listener
    public interface GreetingTaskListener{
        void onGreetingGenerated(String greetingText);
    }

    ......

    // 模拟计算过程，返回一个随机值。
    @Override
    protected Integer doInBackground(Void... params) {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return (int)(Math.random() * 100);
    }

    @Override
    protected void onPostExecute(Integer randomInt) {
        listener.onGreetingGenerated(baseText + " " + randomInt);
    }
}
</code></pre>

<p><strong>第二步</strong>定义视图接口，视图接口需要继承<code>MvpView</code>：</p>

<pre><code>public interface HelloWorldView extends MvpView{

    void showHello(String greetingText);

    void showGoodbye(String greetingText);
}
</code></pre>

<p>注意这里的<code>MvpView</code>是所有视图的顶层接口，它是一个空接口，没有定义任何方法。</p>

<p><strong>第三步</strong>实现Presenter，Presenter需要执行业务逻辑，并针对不同的执行结果调用视图的对应方法。</p>

<p>Presenter的顶层接口是<code>MvpPresenter</code>，它有两个方法：</p>

<pre><code>public interface MvpPresenter&lt;V extends MvpView&gt; {

  /**
   * 将View附着到Presenter上
   */
  public void attachView(V view);

  /**
   * 在视图被摧毁时调用。典型场景是Activity.onDestroy()和Fragment.onDestroyView()方法
   */
  public void detachView(boolean retainInstance);
}
</code></pre>

<p>Mosby提供了<code>MvpPresenter</code>接口的基类实现，在这里我们继承<code>MvpBasePresenter</code>:</p>

<pre><code>public class HelloWorldPresenter extends MvpBasePresenter&lt;HelloWorldView&gt;{

    private GreetingGeneratorTask greetingTask;

    private void cancelGreetingTaskIfRunning(){
        if (greetingTask != null){
            greetingTask.cancel(true);
        }
    }

    public void greetHello(){
        cancelGreetingTaskIfRunning();

        greetingTask = new GreetingGeneratorTask("Hello", new GreetingGeneratorTask.GreetingTaskListener() {
            @Override
            public void onGreetingGenerated(String greetingText) {
                if (isViewAttached()){
                    getView().showHello(greetingText);
                }
            }
        });
        greetingTask.execute();
    }

    ......

    @Override
    public void detachView(boolean retainInstance) {
        super.detachView(retainInstance);
        if (!retainInstance){
            cancelGreetingTaskIfRunning();
        }
    }
}
</code></pre>

<p>注意在<code>detachView</code>方法中取消后台任务的处理。</p>

<p><strong>第四步</strong>实现Activity，让我们的Activity继承<code>MvpActivity</code>，并实现<code>HelloWorldView</code>接口。</p>

<p><code>MvpActivity</code>有两个泛型，分别是Presenter和View的具体类型：</p>

<pre><code>public class HelloWorldActivity extends MvpActivity&lt;HelloWorldView, HelloWorldPresenter&gt; implements HelloWorldView{
    ......
}
</code></pre>

<p>继承<code>MvpActivity</code>后，只有一个抽象方法<code>createPresenter()</code>需要实现：</p>

<pre><code>public HelloWorldPresenter createPresenter() {
    return new HelloWorldPresenter();
}
</code></pre>

<p><code>HelloWorldView</code>还有两个方法需要实现：</p>

<pre><code>@Override
public void showHello(String greetingText) {
    greetingTextView.setTextColor(Color.RED);
    greetingTextView.setText(greetingText);

}

@Override
public void showGoodbye(String greetingText) {
    greetingTextView.setTextColor(Color.BLUE);
    greetingTextView.setText(greetingText);
}
</code></pre>

<p>点击按钮后，使用Presenter来完成相关操作：</p>

<pre><code>@OnClick(R.id.helloButton)
public void onHelloButtonClicked(){
    presenter.greetHello();
}

@OnClick(R.id.goodbyeButton)
public void onGoodbyeButtonClicked(){
    presenter.greetGoodbye();
}
</code></pre>

<h3 id="1.4">MvpPresenter的基类</h3>

<p><strong>Presenter默认实现一：</strong>使用弱引用保存视图引用，在调用<code>getView()</code>之前必须判断<code>isViewAttached()</code>。</p>

<pre><code>public class MvpBasePresenter&lt;V extends MvpView&gt; implements MvpPresenter&lt;V&gt; {

  private WeakReference&lt;V&gt; viewRef;

  @Override public void attachView(V view) {
    viewRef = new WeakReference&lt;V&gt;(view);
  }

  @Nullable public V getView() {
    return viewRef == null ? null : viewRef.get();
  }

  public boolean isViewAttached() {
    return viewRef != null &amp;&amp; viewRef.get() != null;
  }

  @Override public void detachView(boolean retainInstance) {
    if (viewRef != null) {
      viewRef.clear();
      viewRef = null;
    }
  }
}
</code></pre>

<p><strong>Presenter默认实现二：</strong>使用Null Object Pattern，在调用<code>getView()</code>时无需判断。</p>

<pre><code>public class MvpNullObjectBasePresenter&lt;V extends MvpView&gt; implements MvpPresenter&lt;V&gt; {

  private V view;

  @Override public void attachView(V view) {
    this.view = view;
  }

  @NonNull public V getView() {
    if (view == null) {
      throw new NullPointerException("MvpView reference is null. Have you called attachView()?");
    }
    return view;
  }

  @Override public void detachView(boolean retainInstance) {
    if (view != null) {

      Type[] types =
          ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments();

      Class&lt;V&gt; viewClass = (Class&lt;V&gt;) types[0];
      view = NoOp.of(viewClass);
    }
  }
}
</code></pre>

<blockquote>
  <p>思考：什么是空对象模式(Null Object Pattern)？</p>
</blockquote>

<h2 id="2">基础</h2>

<h3 id="2.1">LCE视图</h3>

<p>在开发Android应用过程中，我们会发现很多页面有相似的结构和UI逻辑，所以我们常常在写重复代码。如果能抽象出相似页面的View接口，然后封装页面的基类，就能让开发方便很多。Mosby就给我们提供了一个这样的视图模板，叫做<strong>LCE View</strong>。</p>

<p>LCE代表Loading-Content-Error(加载-内容-错误)，此视图有三种状态：显示加载中，显示数据内容，或者显示错误视图。例如在如下的场景中：</p>

<p>假设我们要在<code>ListView</code>中显示一个国家列表，国家列表的数据是从网络获取的，是一个耗时操作。在加载过程中，我们要显示一个<code>ProgressBar</code>，如果加载出错，我们要显示一条错误信息。另外，还要用<code>SwipeRefreshLayout</code>来让用户可以下拉刷新。</p>

<p>LCE View的接口定义如下：</p>

<pre><code>public interface MvpLceView&lt;M&gt; extends MvpView {

  /**
   * 显示加载视图，加载视图的id必须为R.id.loadingView
   */
  public void showLoading(boolean pullToRefresh);

  /**
   * 显示内容视图，内容视图的id必须为R.id.contentView
   *
   * &lt;b&gt;The content view must have the id = R.id.contentView&lt;/b&gt;
   */
  public void showContent();

  /**
   * 显示错误视图，错误视图必须是TextView，id必须是R.id.errorView
   */
  public void showError(Throwable e, boolean pullToRefresh);

  /**
   * 设置将在showContent()中显示的数据
   */
  public void setData(M data);

  /**
   * 加载数据，此方法中常需要调用Presenter的对应方法。因此此方法不可在Presenter
   * 中使用，避免循环调用。
   * 参数pullToRefresh代表此次加载是否由下拉刷新触发。
   */
  public void loadData(boolean pullToRefresh);
}
</code></pre>

<blockquote>
  <p><strong>思考</strong>：LCE视图中考虑了下拉刷新，但没有考虑上拉加载，如果服务器是分页接口，需要添加上拉加载，应该怎样定义视图接口？</p>
</blockquote>

<h3 id="2.2">MvpLceActivity和MvpLceFragment</h3>

<p>Mosby封装了LCE视图的基类，现在我们用MvpLceActivity或MvpLceFragment来实现上面所说的加载国家列表的场景。</p>

<p><strong>第一步</strong>完成界面布局，注意id必须使用上面指定的名称，错误视图只能是一个TextView：</p>

<pre><code>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    ......&gt;
    &lt;include layout="@layout/loading_view" /&gt;
    &lt;include layout="@layout/error_view" /&gt;
    &lt;android.support.v4.widget.SwipeRefreshLayout
        android:id="@+id/contentView"
        ......&gt;
        &lt;ListView ....../&gt;
    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;
&lt;/FrameLayout&gt;
</code></pre>

<p><strong>第二步</strong>继承<code>MvpLceView</code>实现自己的视图接口，此处需要指定泛型，作为数据类型：</p>

<pre><code>public interface CountriesView extends MvpLceView&lt;List&lt;Country&gt;&gt;{
}
</code></pre>

<p><strong>第三部</strong>实现Presenter，在这里我们做了一个接口和一个实现：</p>

<p>接口定义：</p>

<pre><code>public interface CountriesPresenter extends MvpPresenter&lt;CountriesView&gt;{

    void loadCountries(final boolean pullToRefresh);
}
</code></pre>

<p>具体实现：</p>

<pre><code>public class SimpleCountriesPresenter extends MvpNullObjectBasePresenter&lt;CountriesView&gt;
        implements CountriesPresenter{

    ......

    @Override
    public void loadCountries(final boolean pullToRefresh) {
        getView().showLoading(pullToRefresh);

        ......

        countriesLoader = new CountriesAsyncLoader(++failingCounter % 2 != 0, new CountriesAsyncLoader.CountriesLoaderListener() {
            @Override
            public void onSuccess(List&lt;Country&gt; countries) {
                getView().setData(countries);
                getView().showContent();
            }

            @Override
            public void onError(Exception e) {
                getView().showError(e, pullToRefresh);
            }
        });

        countriesLoader.execute();
    }

    ......
}
</code></pre>

<p>上面代码中就使用到了<code>MvpLceView</code>中除<code>loadData()</code>外的全部四个方法。</p>

<p><strong>第四步</strong>实现Activity或者Fragment，先以Activity为例，需要继承<code>MvpLceActivity</code>:</p>

<pre><code>public class CountriesActivity extends MvpLceActivity&lt;SwipeRefreshLayout, List&lt;Country&gt;, CountriesView, CountriesPresenter&gt;
        implements SwipeRefreshLayout.OnRefreshListener, CountriesView{
</code></pre>

<p><code>MvpLceActivity</code>中定义了四个泛型，分别是ContentView的类型，Data的类型，视图接口的类型和Presenter的类型。此处ContentView使用的是SwipeRefreshLayout。</p>

<p>继承<code>MvpLceActivity</code>后有两个方法需要实现：</p>

<pre><code>@Override
protected String getErrorMessage(Throwable e, boolean pullToRefresh) {
    if (pullToRefresh) {
        return "Error while loading countries";
    } else {
        return "Error while loading countries. Click here to retry";
    }
}

@NonNull
@Override
public CountriesPresenter createPresenter() {
    return new SimpleCountriesPresenter();
}
</code></pre>

<p>实现<code>CountriesView</code>接口后，重写如下几个方法：</p>

<pre><code>@Override
public void setData(List&lt;Country&gt; data) {
    adapter.clear();
    adapter.addAll(data);
    adapter.notifyDataSetChanged();
}

@Override
public void showContent() {
    super.showContent();
    contentView.setRefreshing(false);
}

@Override
public void showError(Throwable e, boolean pullToRefresh) {
    super.showError(e, pullToRefresh);
    contentView.setRefreshing(false);
}

@Override
public void loadData(boolean pullToRefresh) {
    presenter.loadCountries(pullToRefresh);
}
</code></pre>

<p>实现<code>OnRefreshListener</code>接口后，需要实现一个方法：</p>

<pre><code>@Override
public void onRefresh() {
    loadData(true);
}
</code></pre>

<p>如果要用Fragment，方法基本上一样，只需继承<code>MvpLceFragment</code>，唯一的区别是，Activity的初始化在<code>onCreate()</code>中完成，Fragment的初始化在<code>onViewCreated()</code>中完成：</p>

<p>在Activity中：</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.countries_list);
    ButterKnife.bind(this);

    contentView.setOnRefreshListener(this);
    adapter = new ArrayAdapter&lt;&gt;(this, android.R.layout.simple_list_item_1);
    listView.setAdapter(adapter);
    loadData(false);
}
</code></pre>

<p>在Fragment中：</p>

<pre><code>@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    ButterKnife.bind(this, view);

    contentView.setOnRefreshListener(this);

    contentView.setOnRefreshListener(this);
    adapter = new ArrayAdapter&lt;&gt;(getContext(), android.R.layout.simple_list_item_1);
    listView.setAdapter(adapter);
    loadData(false);
}
</code></pre>

<h3 id="2.3">ViewState简介</h3>

<p>在Android开发中有一个很麻烦的问题，就是在界面被销毁、被重建的过程中保存和恢复视图状态。界面被系统回收和重建常常发生在这两个场景中：</p>

<ul>
<li>Configuration变化，例如屏幕在横竖屏之间切换，语言环境变化等。</li>
<li>界面切到后台(例如用户按Home键)，Android在内存过低时自动回收此Activity，在界面重新显示时重建Activity。</li>
</ul>

<blockquote>
  <p><strong>思考</strong>：两种Activity被回收和重建的场景，有什么区别？</p>
</blockquote>

<p>Mosby提供了一个<strong>ViewState</strong>特性来解决这一问题。<code>ViewState</code>是一个接口，只有一个<code>apply</code>方法：</p>

<pre><code>public interface ViewState&lt;V extends MvpView&gt; {

  /**
   * Called to apply this viewstate on a given view.
   *
   * @param view The {@link MvpView}
   * @param retained true, if the components like the viewstate and the presenter have been
   * retained
   * because the {@link Fragment#setRetainInstance(boolean)} has been set to true
   */
  public void apply(V view, boolean retained);
}
</code></pre>

<p>例如，上面讲过的MvpLceFragment，如果想在横竖屏切换过程中保存和恢复视图状态，只需改成继承<code>MvpLceViewStateFragment</code>，实现如下一个方法即可：</p>

<pre><code>@Override
public LceViewState&lt;List&lt;Country&gt;, CountriesView&gt; createViewState() {
    setRetainInstance(true);
    return new RetainingLceViewState&lt;&gt;();
}
</code></pre>

<p>这是针对Mosby提供的LceView的ViewState，如果是我们的自定义视图，也可以实现自己的ViewState。整个ViewState特性的实现原理和应用方法比较复杂，这里不做过多介绍。</p>

<h2 id="3">扩展</h2>

<h3 id="3.1">思考</h3>

<ul>
<li><p>MVC，MVP和MVVM之间有什么区别和联系？</p></li>
<li><p>什么是委托模式？委托和继承的区别是什么？使用委托有什么好处？</p></li>
<li><p>什么是library？什么是framework？它们的区别是什么？</p></li>
</ul>

<blockquote>
  <p>提示：library和framework的关键区别是“控制反转”(Inversion of Control)。当你调用library中的方法时，你掌握控制权。但使用framework时，控制是倒转的：由framework来调用你的代码。</p>
  
  <p><img src="http://7xsct4.com1.z0.glb.clouddn.com/16-5-10/52280993.jpg" alt="" /></p>
</blockquote>

<ul>
<li><p>什么是空对象模式(Null Object Pattern)？</p></li>
<li><p>LCE视图中考虑了下拉刷新，但没有考虑上拉加载，如果服务器是分页接口，需要添加上拉加载，应该怎样定义视图接口？</p></li>
<li><p>两种Activity被回收和重建的场景，有什么区别？</p></li>
</ul>

<blockquote>
  <p>提示：参考下面两个方法：</p>
  
  <ul>
  <li><code>Fragmemt.setRetainInstance(boolean retain)</code></li>
  <li><code>Activity.onRetainNonConfigurationInstance()</code></li>
  </ul>
</blockquote>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
